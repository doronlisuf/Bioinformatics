---
title: "Tutorial 1 markdown"
author: "Alona Rabner"
date: "3/22/2021"
output: html_document
---

This manual page was created on `r Sys.Date()` using R version  `r getRversion()`.

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for 
authoring HTML, PDF, and MS Word documents. 
For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

## **Assignment**

* Assignment is performed by “<-”
	 + **object_name <- value**


```{r}
x<-8
y<-10
print(paste("x equals:",x,"y equals:",y))
print(paste("x equals:",x,"y equals:",y),quote=F) 

```

# **Data structures**
## **Vectors**

Vector is sequence of data elements of the same type (numeric, character or logical). Every column of a table will be represented as a vector. 


```{r}
x<-c(3,2,10,5) #create a vector named x with 4 components
x
y<-1:4 #create a vector of sequence of numbers. 
y
z<-seq(0,100,by=10)
z
t<-seq(100,0,-1)
t
t[5]
```
- Use # to comment 
- [1] is indicating that the first element of the vector can be accessed with [1]. 
Subsequent lines show the appropriate index to access the first number in the line.


### **Some math**

```{r}
x+2 #scalar addition
x*2 #scalar multiplication
x^2 #raise each component to the second power
x # x remained unchanged
x<-x*2 #now x change as we perform assignment
x

```

What if we will print a scalar and a vector in the same output ? 

```{r}
x<-8
y<-1:5
y
print(y)
print (paste(x,y),quote=F)

```
### **Assignment of mixed data types**
```{r}
x<-c(5,"Cold",3.2,"a")
x
```


## **Script editor vs console**

- Instead of executing expression-by-expression, you can also execute the complete script in one step using Ctrl+Shift+Enter. 
- Start your script with the packages that you need. If you’ll share your code with others, they can easily see what packages they need to install/load. 
- You can use a console to execute parts of code, or you can use it observe the results of the script/parts of script execution


# **Matrices**

A matrix is an array of rows and columns of the same data type. One of the easiest ways to create a matrix is to combine vectors of equal length using cbind() function.

```{r}
x<-c(6,7,5,4)
y<-c(4,13,6,15)
z<-c(14,3,5,7)
m1<-cbind(x,y,z)
m1
dim(m1)
t(m1)
m1[2,]
m1[,1]
m1[2:4,2:3]

m1<-matrix(1:8,nrow=2)
m1
m2<-matrix(1:8,nrow=2,byrow=TRUE)
m2
```
- By default, the matrix is filled column-by-column. If you set byrow=TRUE 
the matrix will be filled row by row 

# **Data frames**

A data frame is a nxm collection of variables (in the columns) and observations 
(in the rows). Data frame is more general data structure then matrix, as its 
columns can have different data types (numeric, character, factor, etc.)

```{r}
chr <- c("chr1", "chr1", "chr2", "chr2")
strand <- c("-","-","+","+")
start<- c(200,4000,100,400)
end<-c(250,410,200,450)
mydata <- data.frame(chr,start,end,strand)
mydata
#change column names
names(mydata) <- c("chr","start","foo","bar")
mydata[,2:4] # columns 2,3,4 of data frame
mydata$start # variable start in the data frame
mydata[c(1,3),] # get 1st and 3rd rows
mydata[mydata$start>400,] # get all rows where start>400




```

# **Lists**

A list is an ordered collection of components. A list allows you to gather 
a variety of often unrelated objects of different length and type 
under one name. Each object or element in the list has a numbered position 
and can have names. The list can be created with the list() function. 


 
```{r}
#Example of a list with 4 components:
#a string, a numeric vector, a matrix, and a scalar
w <- list(name="Alona",
          mynumbers=c(6,4,3,2,1),
          mymatrix=matrix(1:8,ncol=2),
          age=85)
w
w[[3]] # 3rd component of the list
w[["mynumbers"]] # component named mynumbers in list
w$age

```

# **If/else/ifelse**

if (condition) {    
  # executed when condition is TRUE    
  } else {    
  # executed when condition is FALSE    
  }    

An opening curly brace should never go on its own line and should always 
be followed by a new line. A closing curly brace should always go on its own 
line, unless it’s followed by else. Always indent the code inside curly braces.

**ifelse(test,yes,no)**

ifelse returns a value with the same shape as test which is filled with elements selected from either yes or no depending on whether the element of test is TRUE or FALSE.


```{r}
x<-1:4
ifelse(x=="Blue","Yey!","Neh")
ifelse(x!="Blue","Yey!","Neh")
```


# **For**

```{r}
for (i in 1:10) { #number of repetitions
 print (paste("This is iteration",i)) #the task to be repeated
}

```

# **Functions**
You should consider writing a function if you used the same block of code 
more than twice. Function name must be clear. Don’t worry about name length as 
Rstudio has a perfect autocomplete.

```{r}
sqSum<-function(x,y){
result=x^2+y^2
return(result)
}
# now use this function in your main script
z=sqSum(2,3)
z
```
# **Apply functions family**
- Try to do your best to replace every “for” by the helper functions from the “apply” family. 
- The apply family of functions in base R (apply(), lapply(), tapply(), etc) consists of functions that eliminate the need for many common “for” loops.
- Another option to get rid of “for” loops is to get familiar with the functions in the purrr package.


```{r}
m1=cbind(c(3,0,3,3),c(3,0,0,0),c(3,0,0,3),c(1,1,0,0),c(1,1,1,0),c(1,1,1,0))
m1
#second argument of apply that equals 1, indicates that rows of the matrix /data frame
#will be the input for the function
result<-apply(m1,1,sum)
result
#second argument of apply that equals 2, indicates that columns of the matrix /data frame
#will be the input for the function
result<-apply(m1,2,sum)
result
         
```

# **Additional tips**
Break your code into a well explained blocks

```{r}
# Load data --------------------------
t<-c(1,2,3)
# Plot data --------------------------
z=4
```
- Pay attention to the error messages in the editor window and at the console




