---
title: "Tutorial_11_Markdown"
date: "6/13/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(Seurat)
library(patchwork)
```


Seurat is an R package designed for QC, analysis, and exploration of single-cell RNA-seq data.

```{r}
#pacman::p_install(Seurat)
#pacman::p_install(patchwork)
```

For this tutorial, we will be analyzing the a dataset of Peripheral Blood Mononuclear Cells (PBMC) freely available from 10X Genomics. 
There are 2,700 single cells in the dataset.

We start by reading in the data. The Read10X() function reads in the output of the cellranger pipeline from 10X, returning a unique molecular identified (UMI) count matrix. The values in this matrix represent the number of molecules for each feature (i.e. gene; row) that are detected in each cell (column).
Detailed explanation can be found [here](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices)

```{r}
# Load the PBMC dataset
pbmc.data <- Seurat::Read10X(data.dir = "C:/Users/user/Downloads/hg19/")
#if doesn't work - use install.packages("pkgconfig")

# Lets examine a few genes in the first thirty cells
pbmc.data[c("CD3D", "TCL1A", "MS4A1"), 1:30]
```

The . values in the matrix represent 0s (no molecules detected). Since most values in an scRNA-seq matrix are 0, Seurat uses a sparse-matrix representation whenever possible. This results in significant memory and speed savings for Drop-seq/inDrop/10x data.

We next use the count matrix to create a Seurat object. The object serves as a container that contains both data (like the count matrix) and analysis (like PCA, or clustering results) for a single-cell dataset. For example, the count matrix is stored in pbmc[["RNA"]]@counts (pbmc@assays$RNA@counts)

```{r}
# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- Seurat::CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc
```


### Quality Control

A few QC metrics commonly used by the community:    

1) The number of unique genes detected in each cell:    

-Low-quality cells or empty droplets will often have very few genes
-Cell doublets or multiplets may exhibit an aberrantly high gene count.

2)The total number of molecules detected within a cell

3) The percentage of reads that map to the mitochondrial genome   
Low-quality / dying cells often exhibit extensive mitochondrial contamination      

```{r}
# We calculate mitochondrial QC metrics with the PercentageFeatureSet() function, which calculates the percentage of counts originating from a set of features.
#We use the set of all genes starting with MT- as a set of mitochondrial genes
#The [[ operator can add columns to object metadata. This is a great place to stash QC stats

pbmc[["percent.mt"]] <- Seurat::PercentageFeatureSet(pbmc, pattern = "^MT-")
```

```{r}
# Show QC metrics for the first 5 cells
head(pbmc@meta.data, 5)
```

nFeature_RNA is the number of genes detected in each cell.    
nCount_RNA is the total number of molecules detected within a cell.

To control for empty droplets/cell doublets/triplets We filter cells that have unique feature counts over 2,500 or less than 200.
We filter cells that have >5% mitochondrial counts

```{r}
# Visualize QC metrics as a violin plot
Seurat::VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
```

### Normalizing the data

We will normalize the data ensuring expression values across cells are on a comparable scale.
`NormalizeData` normalize the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in pbmc[["RNA"]]@data.
```{r}
pbmc <- Seurat::NormalizeData(pbmc)
```

### Identification of highly variable features

We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). It has been found that focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets.

```{r}
#We will consider return 2,000 features per dataset.
pbmc <- Seurat::FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
head(pbmc@assays, 5)

# Identify the 10 most highly variable genes
top10 <- head(Seurat::VariableFeatures(pbmc), 10)

# plot variable features with and without labels
plot1 <- Seurat::VariableFeaturePlot(pbmc)
plot2 <- Seurat::LabelPoints(plot = plot1, points = top10)
plot2
```

### Data scaling

Next, we apply a linear transformation (scaling). 
The ScaleData() function:   
1). Shifts the expression of each gene,so that the mean expression across cells is 0
2). Scales the expression of each gene, so that the variance across cells is 1.

This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate.

The results of this are stored in pbmc[["RNA"]]@scale.data
```{r}
all.genes <- rownames(pbmc)
pbmc <- Seurat::ScaleData(pbmc, features = all.genes)
```

### Linear dimensional reduction

```{r}
pbmc <- Seurat::RunPCA(pbmc, features = Seurat::VariableFeatures(object = pbmc))
Seurat::DimPlot(pbmc, reduction = "pca")
pbmc
```

### Determine the dimentionality of dataset

*Seurat clusters cells based on their PCA scores* in order to overcome the extensive technical noise in any single feature for scRNA-seq data. The top principal components represent a robust compression of the dataset.

To decide how many components should we choose to include, we will apply the ‘Elbow plot’ method: a ranking of principle components based on the percentage of variance explained by each one.

```{r}
Seurat::ElbowPlot(pbmc)
```
We can observe an ‘elbow’ around PC9-10, suggesting that the majority of true signal is captured in the first 10 PCs.

### Cluster the data

Seurat applies a graph-based clustering approach.
```{r}
#K-nearest neighbor (KNN) graph based on the euclidean distance in PCA space
pbmc <- Seurat::FindNeighbors(pbmc, dims = 1:10)

pbmc <- Seurat::FindClusters(pbmc, resolution = 0.5)

# Setting the resolution parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. 
```

```{r}
#Look at cluster IDs of first 5 cells
head(Seurat::Idents(pbmc), 5)
```

### Non-linear dimensional reduction (UMAP)

```{r}
pbmc <- Seurat::RunUMAP(pbmc, dims = 1:10)
Seurat::DimPlot(pbmc, reduction = "umap")
#in case it doesn't work try to use reticulate::py_install(packages =
# 'umap-learn')
pbmc
```


### Finding differentially expressed features (cluster biomarkers)

Seurat can help you find markers that define clusters via differential expression. By default, it identifies positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. The min.pct argument requires a feature to be detected at a minimum percentage in either of the two groups of cells.

```{r}
# find all markers of cluster 2
cluster2.markers <- Seurat::FindMarkers(pbmc, ident.1 = 2, min.pct = 0.25)
head(cluster2.markers, n = 5)
```

The results data frame has the following columns :

p_val : p_val (unadjusted)
avg_log2FC : log fold-change of the average expression between the two groups. Positive values indicate that the feature is more highly expressed in the first group.
pct.1 : The percentage of cells where the feature is detected in the first group
pct.2 : The percentage of cells where the feature is detected in the second group
p_val_adj : Adjusted p-value, based on Bonferroni correction using all features in the dataset.


```{r}
# find all markers distinguishing cluster 5 from clusters 0 and 3
cluster5.markers <- Seurat::FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
head(cluster5.markers, n = 5)

```


```{r}
# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- Seurat::FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>%
    group_by(cluster) %>%
    top_n(n = 2, wt = avg_log2FC)
```

To visualize marker expression we will use and FeaturePlot():
```{r}
Seurat::FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", 
    "CD8A"))
```

DoHeatmap() generates an expression heatmap for given cells and features. 

```{r}

top10 <- pbmc.markers %>%
    group_by(cluster) %>%
    top_n(n = 10, wt = avg_log2FC)
Seurat::DoHeatmap(pbmc, features = top10$gene) + NoLegend()
```

### Annotation of the clusters using known markers

Our markers are known markers for specific pbmc :

Cluster ID	Markers	Cell Type   
0	IL7R, CCR7	Naive CD4+ T    
1	CD14, LYZ	CD14+ Mono    
2	IL7R, S100A4	Memory CD4+   
3	MS4A1	B   
4	CD8A	CD8+ T    
5	FCGR3A, MS4A7	FCGR3A+ Mono    
6	GNLY, NKG7	NK    
7	FCER1A, CST3	DC    
8	PPBP	Platelet    
  

```{r}
new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono", 
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- Seurat::RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

